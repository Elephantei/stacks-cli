# https://taskfile.dev

version: '3'

env:
  BUILDNUMBER: '{{ .BUILDNUMBER | default "100.98.99" }}'
  DOCS_DIR: docs/
  OUTPUT_DIR: outputs
  OUTPUT_TEST_DIR: "{{.OUTPUT_DIR}}/tests"
  OUTPUT_INTTEST_DIR: "{{.OUTPUT_DIR}}/integration_tests"
  OUTPUT_BIN_DIR: "{{.OUTPUT_DIR}}/bin"
  OUTPUT_DOCS_DIR: "{{.OUTPUT_DIR}}/docs"
  OUTPUT_DOCS_PDF_DIR: "{{.OUTPUT_DOCS_DIR}}/pdf"
  OUTPUT_DOCS_MD_DIR: "{{.OUTPUT_DOCS_DIR}}/md"
  BIN_DIR: '{{ .BIN_DIR | default "bin" }}'
  WORKING_DIR: '{{ .WORKING_DIR | default "projects" }}'

vars:
  REPORT_OUTPUT: report.xml
  INTEGRATION_REPORT_OUTPUT: integration_report.xml
  COVERAGE_REPORT: coverage.xml

# dotenv: ['.env']

tasks:
  default:
    desc: Compile CLI and run tests
    cmds:
      - task: test
      - task: compile

  clean:
    desc: Clean out old any old builds
    cmds:
      - rm -rf {{.OUTPUT_DIR}}

  test:
    desc: Run tests and reports
    cmds:
      - task: test:execute
      - task: test:reports
      
  test:setup:
    desc: Setup the tests
    cmds:
      - cmd: mkdir -p {{.OUTPUT_TEST_DIR}}
      - cmd: mkdir -p {{.OUTPUT_INTTEST_DIR}}
      - go get github.com/jstemmer/go-junit-report

  test:execute:
    desc: Run Unit Tests
    cmds:
      - task: test:setup
      - go get github.com/axw/gocov/gocov
      - go get github.com/AlekSi/gocov-xml
      - go test ./... -v | go-junit-report > {{.OUTPUT_TEST_DIR}}/{{.REPORT_OUTPUT}}
      - go test ./... -v -coverprofile={{.OUTPUT_TEST_DIR}}/cover.out
      - go mod tidy

  test:reports:
    desc: Produce reports
    cmds:
      - gocov convert {{.OUTPUT_TEST_DIR}}/cover.out > {{.OUTPUT_TEST_DIR}}/cover.convert.out
      - cat {{.OUTPUT_TEST_DIR}}/cover.convert.out | gocov-xml > {{.OUTPUT_TEST_DIR}}/{{.COVERAGE_REPORT}}
      - rm {{.OUTPUT_TEST_DIR}}/*.out

    # Ensure that the files are available for conversion
    preconditions:
      - sh: test -f {{.OUTPUT_TEST_DIR}}/cover.out
        msg: "Coverage report does not exist: {{.OUTPUT_TEST_DIR}}/cover.out"

  # Run the integration tests using the binary that can be found in the BIN_DIR
  # The test binary does not like to use the pipe symbol, so the test results are redirected to a text file
  # and then output to go-junit-report so that the main report file can be generated
  # The temporary report file is then deleted.
  test:integration:
    desc: Run Integration tests
    cmds:
      - task: test:setup
      - chmod +x {{.BIN_DIR}}/*
      - "{{.BIN_DIR}}/stacks-cli-{{OS}}-inttest-amd64-{{.BUILDNUMBER}} --test.v --projectdir {{.WORKING_DIR}} --binarycmd {{.BIN_DIR}}/stacks-cli-{{OS}}-amd64-{{.BUILDNUMBER}} > {{.OUTPUT_TEST_DIR}}/integration_report.temp.out"
      - "cat {{.OUTPUT_TEST_DIR}}/integration_report.temp.out | go-junit-report > {{.OUTPUT_TEST_DIR}}/integration_test.xml"
      - "rm {{.OUTPUT_TEST_DIR}}/integration_report.temp.out"
      - go mod tidy

  compile:cmd:
    cmds:
      - go build -ldflags "-X github.com/amido/stacks-cli/cmd.version={{.BUILDNUMBER}}" -o {{.OUTPUT_BIN_DIR}}/stacks-cli-{{.PLATFORM_OS}}-{{.PLATFORM_ARCH}}-{{.BUILDNUMBER}}{{.PLATFORM_EXTENSION}}
      - go test -tags integration -o {{.OUTPUT_BIN_DIR}}/stacks-cli-{{.PLATFORM_OS}}-inttest-{{.PLATFORM_ARCH}}-{{.BUILDNUMBER}}{{.PLATFORM_EXTENSION}} -c github.com/amido/stacks-cli/testing/integration/...
  
    env:
      GOOS: '{{ .PLATFORM_OS }}'
      GOARCH: '{{ .PLATFORM_ARCH }}'

  compile:
    desc: Compile supports platforms

    deps:
      - task: compile:cmd
        vars:
          PLATFORM_OS: windows
          PLATFORM_ARCH: amd64
          PLATFORM_EXTENSION: ".exe"
      - task: compile:cmd
        vars:
          PLATFORM_OS: linux
          PLATFORM_ARCH: amd64
          PLATFORM_EXTENSION:
      - task: compile:cmd
        vars:
          PLATFORM_OS: darwin
          PLATFORM_ARCH: amd64
          PLATFORM_EXTENSION:          
      
  docs:
    desc: Generate all the documentation formats

    cmds:
      - task: docs:setup
      - task: docs:pdf
      - task: docs:markdown

  docs:pdf:
    desc: Generate a PDF of the current documentation

    cmds:
      - docker run --rm -v ${PWD}:/data russellseymour/pandoc-asciidoctor asciidoctor-pdf -a pdf-theme=/data/docs/styles/theme.yml -a pdf-fontsdir="/data/docs/styles/fonts;GEM_FONTS_DIR" -a doctype="book" -a stackscli_version="{{.BUILDNUMBER}}" -o "{{.DOCS_FILENAME}}" -a toc -D /data/{{.OUTPUT_DOCS_PDF_DIR}} /data/docs/manual.adoc

    vars:
      DOCS_FILENAME: "Stacks CLI Manual - {{.BUILDNUMBER}}.pdf"

  docs:markdown:
    cmds:
      - docker run -v ${PWD}:{{ .CONTAINER_DIR }} russellseymour/pandoc-asciidoctor pwsh -command {{ .CONTAINER_DIR }}/build/scripts/ConvertTo-Markdown.ps1 -docs_dir {{ .CONTAINER_DIR }}/{{ .DOCS_DIR }} -output_dir {{ .CONTAINER_DIR }}/{{ .OUTPUT_DOCS_MD_DIR }}
      - cp -r ${PWD}/docs/images ${PWD}/outputs/docs/md/

    vars:
      CONTAINER_DIR: /data

  docs:setup:
    cmds:
      - docker pull russellseymour/pandoc-asciidoctor
      - mkdir -p ${PWD}/{{ .OUTPUT_DOCS_MD_DIR }}       
      - mkdir -p ${PWD}/{{ .OUTPUT_DOCS_PDF_DIR }}      

  release:
    desc: Create a release

    cmds:
      - |
        pwsh -NoProfile -Command build/scripts/Publish-GitHubRelease.ps1

    env:
      # Define env vars to be used for the release
      VERSION_NUMBER: '{{ .BUILDNUMBER }}'
      API_KEY: '{{ .API_KEY }}'
      NOTES: '{{ .NOTES }}'
      COMMIT_ID: '{{ .COMMIT_ID }}'
      ARTIFACTS_DIR: '{{ .ARTIFACTS_DIR }}'
      OWNER: '{{ .OWNER | default "amido" }}'
      REPOSITORY: '{{ .REPOSITORY | default "stacks-cli" }}'
      DRAFT: '{{ .DRAFT }}'
      PRERELEASE: '{{ .PRERELEASE }}'
